package main

import (
	"context"
	"fmt"
	"io"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"syscall"
	"time"

	"github.com/go-qamel/qamel"
)

// VaultManager manages vault unlocking / locking. It does not manage vault information storage.
/*
  Signals (events):
  - vaultUnlocked(vaultPath, mountPoint)
  - vaultLocked(vaultPath)
  - alert(message)
  Slots (methods available to Javascript):
  - unlockVault(vaultPath, password)
  - lockVault(vaultPath)
  - revealVault(vaultPath)
  - revealMountPoint(vaultPath)
  - createNewVault(name, location, password)
  - lockAllVaults()
  Properties:
  - fuseAvailable <bool>
*/
type VaultManager struct {
	qamel.QmlObject
	_           func()                           `constructor:"init"`
	_           func(string, string) int         `slot:"unlockVault"`
	_           func(string) int                 `slot:"lockVault"`
	_           func(string)                     `slot:"revealVault"`
	_           func(string)                     `slot:"revealMountPoint"`
	_           func(string, string, string) int `slot:"createNewVault"`
	_           func() int                       `slot:"lockAllVaults"`
	_           bool                             `property:"fuseAvailable"`
	_           func(string, string)             `signal:"vaultUnlocked"`
	_           func(string)                     `signal:"vaultLocked"`
	_           func(string)                     `signal:"alert"`
	processes   map[string]*exec.Cmd
	mountpoints map[string]string
	cmd         string // Path to `gocryptfs` binary
}

func (vm *VaultManager) init() {
	vm.processes = map[string]*exec.Cmd{}
	vm.mountpoints = map[string]string{}

	// Find gocryptfs binary
	if executable, err := os.Executable(); err == nil {
		cmdBin := filepath.Join(filepath.Dir(executable), "gocryptfs")
		if _, err := os.Stat(cmdBin); os.IsNotExist(err) {
			cmdBin, err = exec.LookPath("gocryptfs")
			if err != nil {
				logger.Fatal().Err(err).Msg("Failed to find gocryptfs binary")
			}
		}
		vm.cmd = cmdBin
		logger.Info().Str("binary", cmdBin).Msg("Found gocryptfs binary")
	} else {
		logger.Fatal().Err(err).Msg("Failed to get executable directory")
	}

	// Detect FUSE availability
	// Property setter and getter is automatically generated by qamel
	// See: https://github.com/go-qamel/qamel/wiki/QmlObject-Documentation#properties
	vm.setFuseAvailable(false)
	const loadFuseBin string = "/Library/Filesystems/osxfuse.fs/Contents/Resources/load_osxfuse"
	if info, err := os.Stat(loadFuseBin); err == nil {
		vm.setFuseAvailable(!info.IsDir())
	}

	// RNG seeding to prevent guessing volume name
	rand.Seed(time.Now().UnixNano() + int64(os.Getpid()))
}

// unlockVault starts a gocryptfs process to unlock and mount the given vault.
// The vault will be mounted to a path with random directory name.
// Return code 0 means ok.
func (vm *VaultManager) unlockVault(vaultPath string, password string) int {
	if cmd, ok := vm.processes[vaultPath]; ok {
		// Existing process will return <nil> to SIG0
		if err := cmd.Process.Signal(syscall.Signal(0)); err == nil {
			vm.alert("Vault already unlocked")
			return 1
		}
	}

	mountPoint := filepath.Join("/Volumes", strconv.FormatInt(int64(rand.Int31()), 16))

	// Please refer to gocryptfs cmd ABI here:
	// https://github.com/rfjakob/gocryptfs/blob/3b61244b72f74a25651d4ba184ac7cc62c937db0/Documentation/CLI_ABI.md#mount
	args := []string{
		"-fg",
		"--",
		vaultPath, mountPoint,
	}
	vm.processes[vaultPath] = exec.Command(vm.cmd, args...)
	vm.mountpoints[vaultPath] = mountPoint
	stdin, err := vm.processes[vaultPath].StdinPipe()
	if err != nil {
		logger.Error().
			Err(err).
			Str("vaultPath", vaultPath).
			Msg("Failed to create STDIN pipe")
		vm.alert("Failed to create STDIN pipe")
		defer delete(vm.processes, vaultPath)
		defer delete(vm.mountpoints, vaultPath)
		return 2
	}
	go func() {
		defer stdin.Close()
		if _, err = io.WriteString(stdin, password); err != nil {
			logger.Error().Err(err).Str("vaultPath", vaultPath).Msg("Failed to pipe password")
			vm.alert("Failed to pipe password to gocryptfs")
		}
	}()
	vm.processes[vaultPath].Start()
	// Seems to be necessary, otherwise the process becomes zombie after exiting.
	go func() {
		if err := vm.processes[vaultPath].Wait(); err != nil {
			// TODO Read from stderr and display the error message to user
			defer delete(vm.processes, vaultPath)
			rc := vm.processes[vaultPath].ProcessState.ExitCode()
			logger.Debug().Int("RC", rc).Msg("gocryptfs exited")
			switch rc {
			case 10:
				vm.alert("Mountpoint not empty")
			case 12:
				vm.alert("Password incorrect")
			case 23:
				vm.alert("Could not open gocryptfs.conf")
			case 15:
				// gocryptfs interrupted by SIGINT, which means we locked this vault
				break
			default:
				vm.alert(fmt.Sprintf("gocryptfs exited unexpectedly (code %d)", rc))
			}
			defer vm.vaultLocked(vaultPath)
		}
	}()
	if vm.processes[vaultPath].ProcessState != nil {
		vm.alert(fmt.Sprintf(
			"gocryptfs exited too soon (code %d)",
			vm.processes[vaultPath].ProcessState.ExitCode(),
		))
		return 5
	}
	defer vm.vaultUnlocked(vaultPath, mountPoint)
	return 0
}

// lockVault stops the corresponding gocryptfs process, return code 0 means ok
func (vm *VaultManager) lockVault(vaultPath string) int {
	if cmd, ok := vm.processes[vaultPath]; ok {
		// Existing process will return <nil> to SIG0
		if err := cmd.Process.Signal(syscall.Signal(0)); err == nil {
			if err = cmd.Process.Signal(os.Interrupt); err != nil {
				vm.alert("Vault already locked")
				return 1
			}
			defer delete(vm.mountpoints, vaultPath)
		}
	}
	defer vm.vaultLocked(vaultPath)
	return 0
}

// revealVault reveals the encrypted vault in Finder
func (vm *VaultManager) revealVault(vaultPath string) {
	// Finder cannot show hidden items
	if filepath.Base(vaultPath)[0] == '.' {
		return
	}
	// Path does not exist
	if _, err := os.Stat(vaultPath); err != nil && os.IsNotExist(err) {
		return
	}
	RevealInFinder(vaultPath)
}

// revealMountPoint reveals the decrypted mountpoint in Finder for given `vaultPath`
func (vm *VaultManager) revealMountPoint(vaultPath string) {
	if mountPoint, ok := vm.mountpoints[vaultPath]; ok {
		if _, err := os.Stat(mountPoint); err == nil {
			RevealInFinder(mountPoint)
		}
	}
}

// createNewVault creates a vault named `name` in `location` using `password`
// Currently the masterkey is not printed, please remember your password.
func (vm *VaultManager) createNewVault(name string, location string, password string) int {
	// Create vault directory
	vaultDirectory := filepath.Join(location, name)
	info, err := os.Stat(vaultDirectory)
	// An existing file is blocking us from creating the vault directory
	if err == nil && !info.IsDir() {
		logger.Error().
			Str("vaultDirectory", vaultDirectory).
			Msg("Vault directory occupied by a file")
		vm.alert("Vault directory occupied by a file")
		return 1
	}
	if err != nil && os.IsNotExist(err) {
		if err = os.MkdirAll(vaultDirectory, 0700); err != nil {
			logger.Error().
				Err(err).
				Str("vaultDirectory", vaultDirectory).
				Msg("Failed to create vault directory")
			vm.alert("Failed to create vault directory")
			return 5
		}
	}

	// Please refer to gocryptfs cmd ABI here:
	// https://github.com/rfjakob/gocryptfs/blob/3b61244b72f74a25651d4ba184ac7cc62c937db0/Documentation/CLI_ABI.md#initialize-filesystem
	args := []string{
		"-init",
		"--",
		vaultDirectory,
	}
	// Init an empty vault should be a relatively fast task, limiting to 10 seconds
	ctx, cancel := context.WithTimeout(context.TODO(), time.Second*10)
	defer cancel()
	cmd := exec.CommandContext(ctx, vm.cmd, args...)
	stdin, err := cmd.StdinPipe()
	if err != nil {
		logger.Error().
			Err(err).
			Str("vaultDirectory", vaultDirectory).
			Msg("Failed to create STDIN pipe")
		vm.alert("Failed to create STDIN pipe")
		return 2
	}

	go func() {
		defer stdin.Close()
		if _, err := io.WriteString(stdin, password); err != nil {
			logger.Error().
				Err(err).
				Str("vaultDirectory", vaultDirectory).
				Msg("Failed to pipe password")
			vm.alert("Failed to pipe password to gocryptfs")
		}
	}()

	if err := cmd.Run(); err != nil {
		logger.Error().
			Err(err).
			Str("vaultDirectory", vaultDirectory).
			Int("returnCode", cmd.ProcessState.ExitCode()).
			Msg("gocryptfs process exited with error")
		switch cmd.ProcessState.ExitCode() {
		case 6:
			vm.alert(fmt.Sprintf("%s is not an empty directory", vaultDirectory))
		case 22:
			vm.alert("Password is empty")
		case 24:
			vm.alert("Could not create gocryptfs.conf")
		}
		return 4
	}
	return 0
}

// localAllVaults locks all vaults, making the application ready to quit
func (vm *VaultManager) lockAllVaults() int {
	lockRc := 0
	for vaultPath, _ := range vm.processes {
		rc := vm.lockVault(vaultPath)
		if rc != 0 && lockRc == 0 {
			lockRc = rc
		}
	}
	return lockRc
}
